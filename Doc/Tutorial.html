<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title><b>PatMat: SPITBOL-like pattern construction and matching in C++</b></title>
<!-- 2016-08-23 Tue 18:55 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title"><b>PatMat: SPITBOL-like pattern construction and matching in C++</b></h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Pattern Matching Tutorial</a>
<ul>
<li><a href="#sec-1-1">1.1. Concatenation and Alternation</a></li>
<li><a href="#sec-1-2">1.2. Moving the Start Point</a></li>
<li><a href="#sec-1-3">1.3. Other Pattern Elements</a>
<ul>
<li><a href="#sec-1-3-1">1.3.1. Arb</a></li>
<li><a href="#sec-1-3-2">1.3.2. Abort</a></li>
<li><a href="#sec-1-3-3">1.3.3. Fail</a></li>
<li><a href="#sec-1-3-4">1.3.4. Fence</a></li>
<li><a href="#sec-1-3-5">1.3.5. Rem</a></li>
<li><a href="#sec-1-3-6">1.3.6. Succeed</a></li>
</ul>
</li>
<li><a href="#sec-1-4">1.4. Pattern Construction Functions</a>
<ul>
<li><a href="#sec-1-4-1">1.4.1. Any(S)</a></li>
<li><a href="#sec-1-4-2">1.4.2. Arbno(P)</a></li>
<li><a href="#sec-1-4-3">1.4.3. Bal(Open, Close)</a></li>
<li><a href="#sec-1-4-4">1.4.4. Break(S)</a></li>
<li><a href="#sec-1-4-5">1.4.5. BreakX(S)</a></li>
<li><a href="#sec-1-4-6">1.4.6. Fence(P)</a></li>
<li><a href="#sec-1-4-7">1.4.7. Len(N)</a></li>
<li><a href="#sec-1-4-8">1.4.8. NotAny(S)</a></li>
<li><a href="#sec-1-4-9">1.4.9. NSpan(S)</a></li>
<li><a href="#sec-1-4-10">1.4.10. Pos(N)</a></li>
<li><a href="#sec-1-4-11">1.4.11. Rpos(N)</a></li>
<li><a href="#sec-1-4-12">1.4.12. Rtab(N)</a></li>
<li><a href="#sec-1-4-13">1.4.13. Tab(N)</a></li>
<li><a href="#sec-1-4-14">1.4.14. Span(S)</a></li>
</ul>
</li>
<li><a href="#sec-1-5">1.5. Recursive Pattern Matching</a></li>
<li><a href="#sec-1-6">1.6. Pattern Assignment Operations</a></li>
<li><a href="#sec-1-7">1.7. Deferred Matching</a></li>
<li><a href="#sec-1-8">1.8. Deferred Replacement</a></li>
<li><a href="#sec-1-9">1.9. Examples of Pattern Matching</a></li>
<li><a href="#sec-1-10">1.10. Correspondence with Pattern Matching in SPITBOL</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Example Code</a></li>
<li><a href="#sec-3">3. Pattern Functions and Operators</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Pattern Matching Tutorial</h2>
<div class="outline-text-2" id="text-1">
<p>
A pattern matching operation (a call to one of the <code>Match</code> functions) takes a
subject string and a pattern, and optionally a replacement string. The
replacement string option is only allowed if the subject is a variable.
</p>

<p>
The pattern is matched against the subject string, and either the match fails,
or it succeeds matching a contiguous sub-string. If a replacement string is
specified, then the subject string is modified by replacing the matched
sub-string with the given replacement.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Concatenation and Alternation</h3>
<div class="outline-text-3" id="text-1-1">
<p>
A pattern consists of a series of pattern elements. The pattern is built up
using either the concatenation operator:
</p>
<div class="org-src-container">

<pre class="src src-c++">A &amp; B
</pre>
</div>
<p>
which means match <code>A</code> followed immediately by matching B, or the alternation
operator:
</p>
<div class="org-src-container">

<pre class="src src-c++">A | B
</pre>
</div>
<p>
which means first attempt to match <code>A</code>, and then if that does not succeed,
match <code>B</code>.
</p>

<p>
There is full backtracking, which means that if a given pattern element
fails to match, then previous alternatives are matched.  For example if we
have the pattern:
</p>
<div class="org-src-container">

<pre class="src src-c++">(A | B) &amp; (C | D) &amp; (E | F)
</pre>
</div>
<p>
First we attempt to match <code>A</code>, if that succeeds, then we go on to try to
match <code>C</code>, and if that succeeds, we go on to try to match <code>E</code>. If <code>E</code> fails,
then we try <code>F</code>. If <code>F</code> fails, then we go back and try matching <code>D</code> instead
of <code>C</code>. Let's make this explicit using a specific example, and introducing
the simplest kind of pattern element, which is a literal string. The meaning
of this pattern element is simply to match the characters that correspond to
the string characters. Now let's rewrite the above pattern form with
specific string literals as the pattern elements:
</p>
<div class="org-src-container">

<pre class="src src-c++">(<span style="color: #008b00;">"ABC"</span> | <span style="color: #008b00;">"AB"</span>) &amp; (<span style="color: #008b00;">"DEF"</span> | <span style="color: #008b00;">"CDE"</span>) &amp; (<span style="color: #008b00;">"GH"</span> | <span style="color: #008b00;">"IJ"</span>)
</pre>
</div>
<p>
The following strings will be attempted in sequence:
</p>
<div class="org-src-container">

<pre class="src src-c++">ABC . DEF . GH
ABC . DEF . IJ
ABC . CDE . GH
ABC . CDE . IJ
AB . DEF . GH
AB . DEF . IJ
AB . CDE . GH
AB . CDE . IJ
</pre>
</div>
<p>
Here we use the dot simply to separate the pieces of the string matched by
the three separate elements.
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Moving the Start Point</h3>
<div class="outline-text-3" id="text-1-2">
<p>
A pattern is not required to match starting at the first character of the
string, and is not required to match to the end of the string.  The first
attempt does indeed attempt to match starting at the first character of the
string, trying all the possible alternatives. But if all alternatives fail,
then the starting point of the match is moved one character, and all
possible alternatives are attempted at the new anchor point.
</p>

<p>
The entire match fails only when every possible starting point has been
attempted. As an example, suppose that we had the subject string
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #008b00;">"ABABCDEIJKL"</span>
</pre>
</div>
<p>
matched using the pattern in the previous example:
</p>
<div class="org-src-container">

<pre class="src src-c++">(<span style="color: #008b00;">"ABC"</span> | <span style="color: #008b00;">"AB"</span>) &amp; (<span style="color: #008b00;">"DEF"</span> | <span style="color: #008b00;">"CDE"</span>) &amp; (<span style="color: #008b00;">"GH"</span> | <span style="color: #008b00;">"IJ"</span>)
</pre>
</div>
<p>
would succeed, after two anchor point moves:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #008b00;">"ABABCDEIJKL"</span>
   ^^^^^^^
   matched
   section
</pre>
</div>
<p>
This mode of pattern matching is called the unanchored mode. It is also
possible to put the pattern matcher into anchored mode by providing the
optional flag Pattern::anchor to the <code>Match</code> function.  This will cause the
match to be performed in anchored mode, where the match is required to
start at the first character.
</p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Other Pattern Elements</h3>
<div class="outline-text-3" id="text-1-3">
<p>
In addition to strings (or single characters), there are many special
pattern elements that correspond to special predefined alternations:
</p>
</div>
<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> Arb</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
Matches any string.  First it matches the null string, and then on a
subsequent failure, matches one character, and then two characters, and so
on. It only fails if the entire remaining string is matched.
</p>
</div>
</div>
<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> Abort</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Immediately aborts the entire pattern match, signalling failure. This is a
specialized pattern element, which is useful in conjunction with some of
the special pattern elements that have side effects.
</p>
</div>
</div>
<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3"><span class="section-number-4">1.3.3</span> Fail</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
The null alternation. Matches no possible strings, so it always signals
failure. This is a specialized pattern element, which is useful in
conjunction with some of the special pattern elements that have side
effects.
</p>
</div>
</div>
<div id="outline-container-sec-1-3-4" class="outline-4">
<h4 id="sec-1-3-4"><span class="section-number-4">1.3.4</span> Fence</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
Matches the null string at first, and then if a failure causes
alternatives to be sought, aborts the match (like a <code>Cancel</code>). Note that
using <code>Fence</code> at the start of a pattern has the same effect as matching in
anchored mode.
</p>
</div>
</div>
<div id="outline-container-sec-1-3-5" class="outline-4">
<h4 id="sec-1-3-5"><span class="section-number-4">1.3.5</span> Rem</h4>
<div class="outline-text-4" id="text-1-3-5">
<p>
Matches from the current point to the last character in the string. This
is a specialized pattern element, which is useful in conjunction with some
of the special pattern elements that have side effects.
</p>
</div>
</div>
<div id="outline-container-sec-1-3-6" class="outline-4">
<h4 id="sec-1-3-6"><span class="section-number-4">1.3.6</span> Succeed</h4>
<div class="outline-text-4" id="text-1-3-6">
<p>
Repeatedly matches the null string.  It is equivalent to the alternation
</p>
<div class="org-src-container">

<pre class="src src-c++">(<span style="color: #008b00;">""</span> | <span style="color: #008b00;">""</span> | <span style="color: #008b00;">""</span> ....).
</pre>
</div>
<p>
This is a special pattern element, which is useful in conjunction with
some of the special pattern elements that have side effects.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Pattern Construction Functions</h3>
<div class="outline-text-3" id="text-1-4">
<p>
The following functions construct additional pattern elements
</p>
</div>
<div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1"><span class="section-number-4">1.4.1</span> Any(S)</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
Where <code>S</code> is a string, matches a single character that is any one of the
characters in <code>S</code>. Fails if the current character is not one of the given
set of characters.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2"><span class="section-number-4">1.4.2</span> Arbno(P)</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
Where <code>P</code> is any pattern, matches any number of instances of the pattern,
starting with zero occurrences. It is thus equivalent to
</p>
<div class="org-src-container">

<pre class="src src-c++">(<span style="color: #008b00;">""</span> | (P &amp; (<span style="color: #008b00;">""</span> | (P &amp; (<span style="color: #008b00;">""</span> ....)))).
</pre>
</div>
<p>
The pattern <code>P</code> may contain any number of
pattern elements including the use of alternatiion and concatenation.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-3" class="outline-4">
<h4 id="sec-1-4-3"><span class="section-number-4">1.4.3</span> Bal(Open, Close)</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
Matches a non-empty string that is parentheses balanced with respect to
characters <code>Open</code> and <code>Close</code>.  Examples of balanced strings are "ABC",
"A((B)C)", and "A(B)C(D)E".  <code>Bal(Open, Close)</code> matches the shortest
possible balanced string on the first attempt, and if there is a
subsequent failure, attempts to extend the string.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-4" class="outline-4">
<h4 id="sec-1-4-4"><span class="section-number-4">1.4.4</span> Break(S)</h4>
<div class="outline-text-4" id="text-1-4-4">
<p>
Where <code>S</code> is a string, matches a string of zero or more characters up to
but not including a break character that is one of the characters given in
the string <code>S</code>.  Can match the null string, but cannot match the last
character in the string, since a break character is required to be
present.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-5" class="outline-4">
<h4 id="sec-1-4-5"><span class="section-number-4">1.4.5</span> BreakX(S)</h4>
<div class="outline-text-4" id="text-1-4-5">
<p>
Where <code>S</code> is a string, behaves exactly like <code>Break(S)</code> when it first
matches, but if a string is successfully matched, then a susequent failure
causes an attempt to extend the matched string.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-6" class="outline-4">
<h4 id="sec-1-4-6"><span class="section-number-4">1.4.6</span> Fence(P)</h4>
<div class="outline-text-4" id="text-1-4-6">
<p>
Where <code>P</code> is a pattern, attempts to match the pattern <code>P</code> including trying
all possible alternatives of <code>P</code>. If none of these alternatives succeeds,
then the <code>Fence</code> pattern fails. If one alternative succeeds, then the
pattern match proceeds, but on a subsequent failure, no attempt is made to
search for alternative matches of <code>P</code>. The pattern <code>P</code> may contain any
number of pattern elements including the use of alternatiion and
concatenation.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-7" class="outline-4">
<h4 id="sec-1-4-7"><span class="section-number-4">1.4.7</span> Len(N)</h4>
<div class="outline-text-4" id="text-1-4-7">
<p>
Where <code>N</code> is a natural number, matches the given number of characters. For
example, <code>Len(10)</code> matches any string that is exactly 10 characters long.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-8" class="outline-4">
<h4 id="sec-1-4-8"><span class="section-number-4">1.4.8</span> NotAny(S)</h4>
<div class="outline-text-4" id="text-1-4-8">
<p>
Where <code>S</code> is a string, matches a single character that is not one of the
characters of <code>S</code>. Fails if the current characer is one of the given set
of characters.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-9" class="outline-4">
<h4 id="sec-1-4-9"><span class="section-number-4">1.4.9</span> NSpan(S)</h4>
<div class="outline-text-4" id="text-1-4-9">
<p>
Where <code>S</code> is a string, matches a string of zero or more characters that is
among the characters given in the string. Always matches the longest
possible such string.  Always succeeds, since it can match the null
string.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-10" class="outline-4">
<h4 id="sec-1-4-10"><span class="section-number-4">1.4.10</span> Pos(N)</h4>
<div class="outline-text-4" id="text-1-4-10">
<p>
Where <code>N</code> is a natural number, matches the null string if exactly <code>N</code>
characters have been matched so far, and otherwise fails.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-11" class="outline-4">
<h4 id="sec-1-4-11"><span class="section-number-4">1.4.11</span> Rpos(N)</h4>
<div class="outline-text-4" id="text-1-4-11">
<p>
Where <code>N</code> is a natural number, matches the null string if exactly <code>N</code>
characters remain to be matched, and otherwise fails.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-12" class="outline-4">
<h4 id="sec-1-4-12"><span class="section-number-4">1.4.12</span> Rtab(N)</h4>
<div class="outline-text-4" id="text-1-4-12">
<p>
Where <code>N</code> is a natural number, matches characters from the current
position until exactly <code>N</code> characters remain to be matched in the
string. Fails if fewer than <code>N</code> unmatched characters remain in the string.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-13" class="outline-4">
<h4 id="sec-1-4-13"><span class="section-number-4">1.4.13</span> Tab(N)</h4>
<div class="outline-text-4" id="text-1-4-13">
<p>
Where <code>N</code> is a natural number, matches characters from the current
position until exactly <code>N</code> characters have been matched in all. Fails if
more than <code>N</code> characters have already been matched.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-14" class="outline-4">
<h4 id="sec-1-4-14"><span class="section-number-4">1.4.14</span> Span(S)</h4>
<div class="outline-text-4" id="text-1-4-14">
<p>
Where <code>S</code> is a string, matches a string of one or more characters that is
among the characters given in the string. Always matches the longest
possible such string.  Fails if the current character is not one of the
given set of characters.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> Recursive Pattern Matching</h3>
<div class="outline-text-3" id="text-1-5">
<p>
The plus operator <code>(+P)</code> where <code>P</code> is a pattern variable, creates a
recursive pattern that will, at pattern matching time, follow the pointer to
obtain the referenced pattern, and then match this pattern. This may be used
to construct recursive patterns. Consider for example:
</p>
<div class="org-src-container">

<pre class="src src-c++">P = (<span style="color: #008b00;">"A"</span> | (<span style="color: #008b00;">"B"</span> &amp; (+P)))
</pre>
</div>
<p>
On the first attempt, this pattern attempts to match the string "A".  If
this fails, then the alternative matches a "B", followed by an attempt to
match <code>P</code> again. This second attempt first attempts to match "A", and so
on. The result is a pattern that will match a string of <code>B</code>'s followed by a
single <code>A</code>.
</p>

<p>
This particular example could simply be written as <code>(NSpan('B') &amp; 'A')</code>, but
the use of recursive patterns in the general case can construct complex
patterns which could not otherwise be built.
</p>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> Pattern Assignment Operations</h3>
<div class="outline-text-3" id="text-1-6">
<p>
In addition to the overall result of a pattern match, which indicates
success or failure, it is often useful to be able to keep track of the
pieces of the subject string that are matched by individual pattern
elements, or subsections of the pattern.
</p>

<p>
The pattern assignment operators allow this capability. The first form is
the immediate assignment:
</p>
<div class="org-src-container">

<pre class="src src-c++">P % S
</pre>
</div>
<p>
Here <code>P</code> is an arbitrary pattern, and <code>S</code> is a variable of type
<code>string</code> that will be set to the sub-string matched by P. This
assignment happens during pattern matching, so if <code>P</code> matches more than
once, then the assignment happens more than once.
</p>

<p>
The deferred assignment operation:
</p>
<div class="org-src-container">

<pre class="src src-c++">P * S
</pre>
</div>
<p>
avoids these multiple assignments by deferring the assignment to the end of
the match. If the entire match is successful, and if the pattern <code>P</code> was
part of the successful match, then at the end of the matching operation the
assignment to <code>S</code> of the string matching <code>P</code> is performed.
</p>

<p>
The cursor assignment operation:
</p>
<div class="org-src-container">

<pre class="src src-c++">Setcur(N)
</pre>
</div>
<p>
assigns the current cursor position to the natural variable <code>N</code>. The cursor
position is defined as the count of characters that have been matched so far
(including any start point moves).
</p>

<p>
Finally the operations <code>%</code> and <code>*</code> may be used with values of type
<code>ostream</code>. The effect is to do a <code>&lt;&lt;</code> operation of the matched
sub-string. These are particularly useful in debugging pattern matches.
</p>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> Deferred Matching</h3>
<div class="outline-text-3" id="text-1-7">
<p>
The pattern construction functions (such as <code>Len</code> and <code>Any</code>) all permit the
use of pointers to natural or string values, or functions that return
natural or string values. These forms cause the actual value to be obtained
at pattern matching time. This allows interesting possibilities for
constructing dynamic patterns as illustrated in the examples section.
</p>

<p>
In addition the <code>(+S)</code> operator may be used where <code>S</code> is a pointer to
string or function returning string, with a similar deferred effect.
</p>

<p>
A special use of deferred matching is the construction of predicate
functions. The element <code>(+P)</code> where <code>P</code> is an access to a function that
returns a <code>bool</code> value, causes the function to be called at the time the
element is matched. If the function returns <code>true</code>, then the null string is
matched, if the function returns <code>false</code>, then failure is signalled and
previous alternatives are sought.
</p>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> Deferred Replacement</h3>
<div class="outline-text-3" id="text-1-8">
<p>
Matching of a non-const string returns as <code>MutableMatchState</code> and then a
subsequent assignment operation to this object performs the required
replacement.
</p>

<p>
Using this approach, we can write:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #0000ff;">string</span> <span style="color: #000000;">c</span>;
<span style="color: #0000ff;">string</span> <span style="color: #000000;">s</span>;
(<span style="color: #008b00;">'('</span> &amp; Len(1) % c &amp; <span style="color: #008b00;">')'</span>)(s) = <span style="color: #008b00;">'['</span> + c + <span style="color: #008b00;">']'</span>;
</pre>
</div>
<p>
An assignment after a failed match has no effect. Note that <code>string s</code>
should not be modified between the calls as it stores the start and end of
the matched sub-string.
</p>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> Examples of Pattern Matching</h3>
<div class="outline-text-3" id="text-1-9">
<p>
First a simple example of the use of pattern replacement to remove a line
number from the start of a string. We assume that the line number has the
form of a string of decimal digits followed by a period, followed by one or
more spaces.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">digs</span> = Span(<span style="color: #008b00;">"0123456789"</span>);
<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">lNum</span> = Pos(0U) &amp; digs &amp; <span style="color: #008b00;">'.'</span> &amp; Span(<span style="color: #008b00;">' '</span>);
</pre>
</div>
<p>
Now to use this pattern we simply do a match with a replacement:
</p>
<div class="org-src-container">

<pre class="src src-c++">lNum(line) = <span style="color: #008b00;">""</span>;
</pre>
</div>
<p>
which replaces the line number by the null string. Note that it is also
possible to use an <code>CharacterSet</code> value as an argument to <code>Span</code> and similar
functions, and in particular all the useful constants 'in
<code>CharacterSet::CharacterSets</code> are available. This means that we could define
<code>Digs</code> as:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">digs</span> = Span(<span style="font-weight: bold; text-decoration: underline;">CharacterSets</span>::digit);
</pre>
</div>
<p>
The style we use here, of defining constant patterns and then using them is
typical.  It is possible to build up patterns dynamically, but it is usually
more efficient to build them in pieces in advance using constant
declarations.  Note in particular that although it is possible to construct
a pattern directly as an argument for the <code>Pattern(string</code> matching
operator, it is much more efficient to preconstruct the pattern as we did in
this example.
</p>

<p>
Now let's look at the use of pattern assignment to break a string into
sections. Suppose that the input string has two Natural decimal
integers, separated by spaces or a comma, with spaces allowed anywhere. Then
we can isolate the two numbers with the following pattern:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #0000ff;">string</span> <span style="color: #000000;">num1</span>, <span style="color: #000000;">num2</span>;
<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">blank</span> = NSpan(<span style="color: #008b00;">' '</span>);
<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">num</span> = Span(<span style="color: #008b00;">"0123456789"</span>);
<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">nums</span> = blank &amp; num % num1 &amp; Span(<span style="color: #008b00;">" ,"</span>) &amp; num % num2;
nums(<span style="color: #008b00;">" 124, 257 "</span>);
</pre>
</div>
<p>
The match operation <code>nums(" 124, 257 ")</code> would assign the string
<code>124</code> to <code>num1</code> and the string <code>257</code> to <code>num2</code>.
</p>

<p>
Now let's see how more complex elements can be built from the set of
primitive elements. The following pattern matches strings that have the
syntax of Ada 95 literals:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">digs</span>  = Span(<span style="font-weight: bold; text-decoration: underline;">CharacterSets</span>::digit);
<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">uDigs</span> = digs &amp; Arbno(<span style="color: #008b00;">'_'</span> &amp; digs);

<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">eDig</span>  = Span(<span style="font-weight: bold; text-decoration: underline;">CharacterSets</span>::xdigit);
<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">ueDdig</span> = eDig &amp; Arbno(<span style="color: #008b00;">'_'</span> &amp; eDig);

<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">bNum</span>  = uDigs &amp; <span style="color: #008b00;">'#'</span> &amp; ueDig &amp; <span style="color: #008b00;">'#'</span>;
</pre>
</div>
<p>
A match against <code>bNum</code> will now match the desired strings, <i>e.g.</i> it will
match <code>16#123_abc#</code>, but not <code>a#b#</code>. However, this pattern is not quite
complete, since it does not allow colons to replace the pound signs. The
following is more complete:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">bChar</span> = Any(<span style="color: #008b00;">"#:"</span>);
<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">bNum</span>  = uDigs &amp; bChar &amp; ueDig &amp; bChar;
</pre>
</div>
<p>
but that is still not quite right, since it allows <code>#</code> and <code>:</code> to be mixed,
and they are supposed to be used consistently.  We solve this by using a
deferred match.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #0000ff;">string</span> <span style="color: #000000;">temp</span>;
<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">bNum</span> = uDigs &amp; bChar % temp &amp; ueDdig &amp; (+temp)
</pre>
</div>
<p>
Here the first instance of the base character is stored in <code>temp</code>, and
then later in the pattern we rematch the value that was assigned.
</p>

<p>
For an example of a recursive pattern, let's define a pattern that is like
the built in <code>Bal(Open, Close)</code>, but the string matched is balanced with
respect to square brackets OR curly brackets.
</p>

<p>
The language for such strings might be defined in extended BNF as
</p>
<div class="org-src-container">

<pre class="src src-c++">ELEMENT ::= &lt;any character other than [] <span style="color: #0000cd; font-weight: bold;">or</span> {}&gt;
           | <span style="color: #008b00;">'['</span> BALANCED_STRING <span style="color: #008b00;">']'</span>
           | <span style="color: #008b00;">'{'</span> BALANCED_STRING <span style="color: #008b00;">'}'</span>

BALANCED_STRING ::= ELEMENT {ELEMENT}
</pre>
</div>
<p>
Here we use <code>{}</code> to indicate zero or more occurrences of a term, as is
common practice in extended BNF. Now we can translate the above BNF into
recursive patterns as follows:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">balancedString</span>;

<span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">element</span> =
    NotAny(<span style="color: #008b00;">"[]{}"</span>)
  | (<span style="color: #008b00;">'['</span> &amp; (+balancedString) &amp; <span style="color: #008b00;">']'</span>)
  | (<span style="color: #008b00;">'{'</span> &amp; (+balancedString) &amp; <span style="color: #008b00;">'}'</span>);

balancedString = element &amp; Arbno(element);
</pre>
</div>
<p>
Note the important use of <code>+</code> here to refer to a pattern not yet defined.
Note also that we use assignments precisely because we cannot refer to as
yet undeclared variables in initializations.
</p>

<p>
Now that this pattern is constructed, we can use it as though it were a new
primitive pattern element, and for example, the match:
</p>
<div class="org-src-container">

<pre class="src src-c++">(balancedString % cout &amp; Fail())(<span style="color: #008b00;">"xy[ab{cd}]"</span>);
</pre>
</div>
<p>
will generate the output:
</p>
<div class="org-src-container">

<pre class="src src-c++">x
<span style="color: #0000ff;">xy</span>
<span style="color: #000000;">xy</span>[ab{cd}]
y
y[ab{cd}]
[ab{cd}]
a
ab
ab{cd}
<span style="color: #0000ff;">b</span>
<span style="color: #000000;">b</span>{cd}
{cd}
c
<span style="color: #0000ff;">cd</span>
<span style="color: #000000;">d</span>
</pre>
</div>
<p>
Note that the function of the fail here is simply to force the pattern
Balanced_String to match all possible alternatives. Studying the operation
of this pattern in detail is highly instructive.
</p>

<p>
Finally we give a rather elaborate example of the use of deferred matching.
The following declarations build up a pattern which will find the longest
string of decimal digits in the subject string.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #0000cd; font-weight: bold;">class</span> <span style="color: #0000ff;">MaxLen</span>
:
    <span style="color: #0000cd; font-weight: bold;">public</span> <span style="color: #0000ff;">BoolGetter</span>
{
    <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">cur_</span>;
    <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">max_</span>;

    <span style="color: #0000cd; font-weight: bold;">public</span>:

        <span style="color: #00008b; font-weight: bold;">MaxLen</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">cur</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">max</span>)
        :
            cur_(cur),
            max_(max)
        {}

        <span style="color: #0000ff;">bool</span> <span style="color: #00008b; font-weight: bold;">get</span>()
        {
            <span style="color: #0000cd; font-weight: bold;">return</span> cur_.size() &gt; max_.size();
        }
};

.
.
.

string cur, max;
<span style="color: #0000ff;">Natural</span> <span style="color: #000000;">loc</span>;

<span style="color: #0000ff;">MaxLen</span> <span style="color: #00008b; font-weight: bold;">GtS</span>(cur, max);

<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">CharacterSet</span>&amp; <span style="color: #000000;">digit</span> = <span style="font-weight: bold; text-decoration: underline;">CharacterSets</span>::digit;
<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">digits</span> = Span(digit);

<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">find</span> =
    <span style="color: #008b00;">""</span> % max &amp; Fence()         &amp; <span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">initialize max to null</span>
    BreakX(digit)              &amp; <span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">scan looking for digits</span>
    ((digits % cur             &amp; <span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">assign next string to cur</span>
     (+GtS)                    &amp; <span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">check cur.size() &gt; max.size()</span>
     Setcur(loc))                <span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">if so, save location</span>
             % max)            &amp; <span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">and assign to max</span>
    Fail();                      <span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">seek all alternatives</span>
</pre>
</div>
<p>
As we see from the comments here, complex patterns like this take on aspects
of sequential programs. In fact they are sequential programs with general
backtracking. In this pattern, we first use a pattern assignment that
matches null and assigns it to <code>max</code>, so that it is initialized for the new
match. Now <code>BreakX</code> scans to the next digit. <code>Arb</code> would do here, but
<code>BreakX</code> will be more efficient.  Once we have found a digit, we scan out
the longest string of digits with <code>Span</code>, and assign it to <code>cur</code>. The
deferred call to <code>GtS.get()</code> tests if the string we assigned to <code>cur</code> is the
longest so far. If not, then failure is signalled, and we seek alternatives
(this means that <code>BreakX</code> will extend and look for the next digit string).
If the call to <code>GtS.get()</code> succeeds then the matched string is assigned as
the largest string so far into <code>max</code> and its location is saved in
<code>loc</code>. Finally <code>Fail</code> forces the match to fail and seek alternatives, so
that the entire string is searched.
</p>

<p>
If the pattern <code>find</code> is matched against a string, the variable <code>max</code> at the
end of the pattern will have the longest string of digits, and <code>loc</code> will be
the starting character location of the string. For example,
<code>find("ab123cd4657ef23")</code> will assign "4657" to <code>max</code> and <code>11</code> to <code>loc</code>
(indicating that the string ends with the eleventh character of the string).
</p>
</div>
</div>

<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10"><span class="section-number-3">1.10</span> Correspondence with Pattern Matching in SPITBOL</h3>
<div class="outline-text-3" id="text-1-10">
<p>
Generally the C++ syntax and names correspond closely to SPITBOL syntax for
pattern matching construction.
</p>

<p>
The basic pattern construction operators are renamed as follows:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #0000ff;">SPITBOL</span>     <span style="color: #00008b; font-weight: bold;">C</span>++
(space)      &amp;
   |         | (Or <span style="color: #0000cd; font-weight: bold;">for</span> Character)
   $         %
   .         *
   *         +
</pre>
</div>
<p>
The C++ operators were chosen so that the relative precedences of these
operators corresponds to that of the SPITBOL operators, but as always, the
use of parentheses is advisable to clarify.
</p>

<p>
The pattern construction operators all have similar names.
</p>

<p>
The actual pattern matching syntax is modified in C++ as follows:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #0000ff;">SPITBOL</span>      <span style="color: #00008b; font-weight: bold;">C</span>++
x y          y(x);
<span style="color: #0000ff;">x</span> <span style="color: #000000;">y</span> = repl   y(x) = repl;
</pre>
</div>
<p>
and pattern failure is indicated by returning a <code>bool</code> result from the
<code>Match</code> function (<code>true</code> for success, <code>false</code> for failure).
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Example Code</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #008b00; font-weight: bold;">#include</span> <span style="color: #008b00;">&lt;string&gt;</span>
<span style="color: #008b00; font-weight: bold;">#include</span> <span style="color: #008b00;">&lt;iostream&gt;</span>

<span style="color: #008b00; font-weight: bold;">#include</span> <span style="color: #008b00;">"Pattern.H"</span>

<span style="color: #0000cd; font-weight: bold;">using</span> <span style="color: #0000cd; font-weight: bold;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">PatMat</span>;
<span style="color: #0000cd; font-weight: bold;">using</span> <span style="color: #0000cd; font-weight: bold;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">std</span>;


<span style="color: #0000cd; font-weight: bold;">class</span> <span style="color: #0000ff;">MaxLen</span>
:
    <span style="color: #0000cd; font-weight: bold;">public</span> <span style="color: #0000ff;">BoolGetter</span>
{
    <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">cur_</span>;
    <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">max_</span>;

    <span style="color: #0000cd; font-weight: bold;">public</span>:

        <span style="color: #00008b; font-weight: bold;">MaxLen</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">cur</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">max</span>)
        :
            cur_(cur),
            max_(max)
        {}

        <span style="color: #0000ff;">bool</span> <span style="color: #00008b; font-weight: bold;">get</span>() <span style="color: #0000cd; font-weight: bold;">const</span>
        {
            <span style="color: #0000cd; font-weight: bold;">return</span> cur_.size() &gt; max_.size();
        }
};


<span style="color: #0000cd; font-weight: bold;">class</span> <span style="color: #0000ff;">Sout</span>
:
    <span style="color: #0000cd; font-weight: bold;">public</span> <span style="color: #0000ff;">StringSetter</span>
{
<span style="color: #0000cd; font-weight: bold;">public</span>:

    <span style="color: #0000ff;">void</span> <span style="color: #00008b; font-weight: bold;">set</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">str</span>)
    {
        cout &lt;&lt; str;
    }
};

<span style="color: #0000ff;">Sout</span> <span style="color: #000000;">sout</span>;


<span style="color: #0000ff;">int</span> <span style="color: #00008b; font-weight: bold;">main</span>()
{
    {
        <span style="color: #0000ff;">string</span> <span style="color: #000000;">s</span>(<span style="color: #008b00;">"Change brackets around a character (c)"</span>);
        <span style="color: #0000ff;">string</span> <span style="color: #000000;">c</span>;
        (<span style="color: #008b00;">'('</span> &amp; Len(1) % c &amp; <span style="color: #008b00;">')'</span>)(s) = <span style="color: #008b00;">'['</span> + c + <span style="color: #008b00;">']'</span>;
        cout &lt;&lt; s &lt;&lt; endl;
    }
    {
        <span style="color: #912cee; font-weight: bold;">//</span><span style="color: #912cee;">const Pattern digs = Span("0123456789");</span>
        <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">digs</span> = Span(<span style="font-weight: bold; text-decoration: underline;">CharacterSets</span>::digit);
        <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">lNum</span> = Pos(0U) &amp; digs &amp; <span style="color: #008b00;">'.'</span> &amp; Span(<span style="color: #008b00;">' '</span>);
        <span style="color: #0000ff;">string</span> <span style="color: #000000;">line</span>(<span style="color: #008b00;">"258. Words etc."</span>);
        lNum(line) = <span style="color: #008b00;">""</span>;
        cout &lt;&lt; line &lt;&lt; endl;
    }
    {
        <span style="color: #0000ff;">string</span> <span style="color: #000000;">num1</span>, <span style="color: #000000;">num2</span>;
        <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">blank</span> = NSpan(<span style="color: #008b00;">' '</span>);
        <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">num</span> = Span(<span style="color: #008b00;">"0123456789"</span>);
        <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">nums</span> = blank &amp; num % num1 &amp; Span(<span style="color: #008b00;">" ,"</span>) &amp; num % num2;
        nums(<span style="color: #008b00;">" 124, 257 "</span>);
        cout &lt;&lt; <span style="color: #008b00;">"num1 = "</span> &lt;&lt; num1 &lt;&lt; <span style="color: #008b00;">"; num2 = "</span> &lt;&lt; num2 &lt;&lt; endl;
    }
    {
        <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">digs</span>  = Span(<span style="font-weight: bold; text-decoration: underline;">CharacterSets</span>::digit);
        <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">uDigs</span> = digs &amp; Arbno(<span style="color: #008b00;">'_'</span> &amp; digs);
        <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">eDig</span>  = Span(<span style="font-weight: bold; text-decoration: underline;">CharacterSets</span>::xdigit);
        <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">ueDig</span> = eDig &amp; Arbno(<span style="color: #008b00;">'_'</span> &amp; eDig);
        <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">bChar</span> = Any(<span style="color: #008b00;">"#:"</span>);
        <span style="color: #0000ff;">string</span> <span style="color: #000000;">temp</span>;
        <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">bNum</span> = uDigs &amp; bChar % temp &amp; ueDig &amp; (+temp);
        <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">string</span> <span style="color: #000000;">subject</span>(<span style="color: #008b00;">"16#123_abc#"</span>);
        <span style="color: #0000cd; font-weight: bold;">if</span> (bNum(subject)) cout &lt;&lt; <span style="color: #008b00;">"Matched "</span> &lt;&lt; subject &lt;&lt; endl;
    }
    {
        <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">balancedString</span>;

        <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">element</span> =
            NotAny(<span style="color: #008b00;">"[]{}"</span>)
          | (<span style="color: #008b00;">'['</span> &amp; (+balancedString) &amp; <span style="color: #008b00;">']'</span>)
          | (<span style="color: #008b00;">'{'</span> &amp; (+balancedString) &amp; <span style="color: #008b00;">'}'</span>);

        balancedString = element &amp; Arbno(element);

        cout &lt;&lt; (balancedString % sout &amp; Fail())(<span style="color: #008b00;">"xy[ab{cd}]"</span>) &lt;&lt; endl;
    }
    {
        <span style="color: #0000ff;">string</span> <span style="color: #000000;">cur</span>, <span style="color: #000000;">max</span>;
        <span style="color: #0000ff;">Natural</span> <span style="color: #000000;">loc</span>;

        <span style="color: #0000ff;">MaxLen</span> <span style="color: #000000;">GtS</span>(cur, max);

        <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">CharacterSet</span>&amp; <span style="color: #000000;">digit</span> = <span style="font-weight: bold; text-decoration: underline;">CharacterSets</span>::digit;
        <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">digits</span> = Span(digit);

        <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #000000;">find</span> =
            <span style="color: #008b00;">""</span> % max &amp; Fence()         &amp; <span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">initialize max to null</span>
            BreakX(digit)              &amp; <span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">scan looking for digits</span>
            ((digits % cur             &amp; <span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">assign next string to cur</span>
             (+GtS)                    &amp; <span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">check cur.size() &gt; max.size()</span>
             Setcur(loc))                <span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">if so, save location</span>
                     % max)            &amp; <span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">and assign to max</span>
            Fail();                      <span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">seek all alternatives</span>

        find(<span style="color: #008b00;">"ab123cd4657ef23"</span>);
        cout&lt;&lt; <span style="color: #008b00;">"max = "</span> &lt;&lt; max &lt;&lt; <span style="color: #008b00;">"; loc = "</span> &lt;&lt; loc &lt;&lt; endl;
    }

    <span style="color: #0000cd; font-weight: bold;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Pattern Functions and Operators</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">/// </span><span style="color: #912cee;">Pattern functions and operators</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Abort</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Constructs a pattern that immediately aborts the entire match</span>
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Abort</span>();

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Alternation</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Creates a pattern that will first try to match l and then on a subsequent</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">failure, attempts to match r instead.</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Matches l followed by r</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">SPITBOL: binary "|"</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">C++: binary "|"</span>

<span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">|</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">l</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">r</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">|</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> *<span style="color: #000000;">l</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">r</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">|</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">l</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">r</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">|</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">l</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> *<span style="color: #000000;">r</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">|</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">l</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">r</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">|</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> *<span style="color: #000000;">l</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">r</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">|</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">l</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> *<span style="color: #000000;">r</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Or</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> *<span style="color: #000000;">l</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> *<span style="color: #000000;">r</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">|</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">l</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">r</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">|</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> <span style="color: #000000;">l</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">r</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">|</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">l</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> <span style="color: #000000;">r</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">|</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">l</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> <span style="color: #000000;">r</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Or</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> *<span style="color: #000000;">l</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> <span style="color: #000000;">r</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">|</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> <span style="color: #000000;">l</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">r</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Or</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> <span style="color: #000000;">l</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> *<span style="color: #000000;">r</span>);

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">/// </span><span style="color: #912cee;">Any</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Constructs a pattern that matches a single character that is one of the</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">characters in the given argument. The pattern fails if the current character</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">is not in str.</span>

<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Any</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> <span style="color: #000000;">c</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Any</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">CharacterSet</span>&amp; <span style="color: #000000;">set</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Any</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">str</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Any</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span> *<span style="color: #000000;">str</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Any</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">StringGetter</span>&amp;);

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">/// </span><span style="color: #912cee;">Arb</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Constructs a pattern that will match any string. On the first attempt, the</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">pattern matches a null string, then on each successive failure, it matches</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">one more character, and only fails if matching the entire rest of the string.</span>

<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Arb</span>();

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Arbno</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Pattern repetition. First matches null, then on a subsequent failure attempts</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">to match an additional instance of the given pattern.  Equivalent to (but</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">more efficient than) P &amp; ("" | (P &amp; ("" | ...</span>

<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Arbno</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> <span style="color: #000000;">c</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Arbno</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">str</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Arbno</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> *<span style="color: #000000;">str</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Arbno</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">p</span>);

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Assignment immediately</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Matches P, and if the match succeeds, assigns the matched sub-string to the</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">given std::string variable S. This assignment happens as soon as the</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">sub-string is matched, and if the pattern P1 is matched more than once during</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">the course of the match, then the assignment will occur more than once.</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">SPITBOL: binary "$"</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">C++: binary "%"</span>

<span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">%</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">p</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">var</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">%</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">p</span>, <span style="color: #0000ff;">StringGetter</span>&amp; <span style="color: #000000;">obj</span>);

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Assignment on match</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Like "%" above, except that the assignment happens at most once after the</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">entire match is completed successfully. If the match fails, then no</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">assignment takes place.</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">SPITBOL: binary "."</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">C++: binary "*"</span>

<span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">*</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">p</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">var</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">*</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">p</span>, <span style="color: #0000ff;">StringGetter</span>&amp; <span style="color: #000000;">obj</span>);

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Bal</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Constructs a pattern that will match any non-empty string that is parentheses</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">balanced with respect to the parentheses characters open and close.</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Attempts to extend the string if a subsequent failure occurs.</span>
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Bal</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> <span style="color: #000000;">open</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> <span style="color: #000000;">close</span>);

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Break</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Constructs a pattern that matches a (possibly null) string which is</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">immediately followed by a character in the given argument. This character is</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">not part of the matched string. The pattern fails if the remaining characters</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">to be matched do not include any of the characters in str.</span>
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Break</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> <span style="color: #000000;">c</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Break</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">CharacterSet</span>&amp; <span style="color: #000000;">set</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Break</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">str</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Break</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span> *<span style="color: #000000;">str</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Break</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">StringGetter</span>&amp;);

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">BreakX</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Like Break, but the pattern attempts to extend on a failure to find the next</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">occurrence of a character in str, and only fails when the last such instance</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">causes a failure.</span>
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">BreakX</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> <span style="color: #000000;">c</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">BreakX</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">CharacterSet</span>&amp; <span style="color: #000000;">set</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">BreakX</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">str</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">BreakX</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span> *<span style="color: #000000;">str</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">BreakX</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">StringGetter</span>&amp;);

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Concatenation operators</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Matches L followed by r</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">SPITBOL: binary " " operator</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">C++: binary "&amp;" operator</span>

<span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">&amp;</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">l</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">r</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">&amp;</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">l</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">r</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">&amp;</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">l</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">r</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">&amp;</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> <span style="color: #000000;">l</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">r</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">&amp;</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">l</span>, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> <span style="color: #000000;">r</span>);

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Deferred Matching</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">SPITBOL: unary "*"</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">C++: unary "+"</span>

<span style="color: #912cee; font-weight: bold;">//</span><span style="color: #912cee;">- This function constructs a pattern which at pattern matching time will</span>
<span style="color: #912cee; font-weight: bold;">//  </span><span style="color: #912cee;">access the current value of this variable, and match against the pattern</span>
<span style="color: #912cee; font-weight: bold;">//  </span><span style="color: #912cee;">value.</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">//  </span><span style="color: #912cee;">Here p must be a Pattern variable.</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">//  </span><span style="color: #912cee;">DANGEROUS if Pattern lifetime longer than referenced variable!!</span>
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Defer</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">p</span>);

<span style="color: #912cee; font-weight: bold;">//</span><span style="color: #912cee;">- This function constructs a pattern which at pattern matching time will</span>
<span style="color: #912cee; font-weight: bold;">//  </span><span style="color: #912cee;">access the current value of this variable, and match against these</span>
<span style="color: #912cee; font-weight: bold;">//  </span><span style="color: #912cee;">characters.</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">//  </span><span style="color: #912cee;">Here str must be a std::string variable.</span>
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Defer</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">str</span>);

<span style="color: #912cee; font-weight: bold;">//</span><span style="color: #912cee;">- Constructs a pattern which at pattern matching time calls the given</span>
<span style="color: #912cee; font-weight: bold;">//  </span><span style="color: #912cee;">function, and then matches against the string or character value that is</span>
<span style="color: #912cee; font-weight: bold;">//  </span><span style="color: #912cee;">returned by the call.</span>
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Defer</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">StringGetter</span>&amp; <span style="color: #000000;">obj</span>);

<span style="color: #912cee; font-weight: bold;">//</span><span style="color: #912cee;">- Constructs a predicate pattern function that at pattern matching time calls</span>
<span style="color: #912cee; font-weight: bold;">//  </span><span style="color: #912cee;">the given function. If True is returned, then the pattern matches.  If False</span>
<span style="color: #912cee; font-weight: bold;">//  </span><span style="color: #912cee;">is returned, then failure is signalled.</span>
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Defer</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">BoolGetter</span>&amp; <span style="color: #000000;">obj</span>);

<span style="color: #0000cd; font-weight: bold;">inline</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">+</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">p</span>)
{
    <span style="color: #0000cd; font-weight: bold;">return</span> Defer(p);
}

<span style="color: #0000cd; font-weight: bold;">inline</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">+</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">s</span>)
{
    <span style="color: #0000cd; font-weight: bold;">return</span> Defer(s);
}

<span style="color: #0000cd; font-weight: bold;">inline</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">+</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">StringGetter</span>&amp; <span style="color: #000000;">obj</span>)
{
    <span style="color: #0000cd; font-weight: bold;">return</span> Defer(obj);
}

<span style="color: #0000cd; font-weight: bold;">inline</span> <span style="color: #0000ff;">Pattern</span> <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">+</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">BoolGetter</span>&amp; <span style="color: #000000;">obj</span>)
{
    <span style="color: #0000cd; font-weight: bold;">return</span> Defer(obj);
}

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Fail</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Constructs a pattern that always fails</span>
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Fail</span>();

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Fence</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Constructs a pattern that matches null on the first attempt, and then causes</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">the entire match to be aborted if a subsequent failure occurs.</span>
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Fence</span>();

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Constructs a pattern that first matches P. if P fails, then the constructed</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">pattern fails. If P succeeds, then the match proceeds, but if subsequent</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">failure occurs, alternatives in P are not sought.  The idea of Fence is that</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">each time the pattern is matched, just one attempt is made to match P,</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">without trying alternatives.</span>
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Fence</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">p</span>);

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Len</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Constructs a pattern that matches exactly the given number of characters. The</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">pattern fails if fewer than this number of characters remain to be matched in</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">the string.</span>
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Len</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Natural</span> <span style="color: #000000;">count</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Len</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">UnsignedGetter</span>&amp; <span style="color: #000000;">count</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Len</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Natural</span> *<span style="color: #000000;">count</span>);

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">NotAny</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Constructs a pattern that matches a single character that is not one of the</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">characters in the given argument. The pattern Fails if the current character</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">is in str.</span>

<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">NotAny</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> <span style="color: #000000;">c</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">NotAny</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">CharacterSet</span>&amp; <span style="color: #000000;">set</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">NotAny</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">str</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">NotAny</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>* <span style="color: #000000;">str</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">NotAny</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">StringGetter</span>&amp;);

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">NSpan</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Constructs a pattern that matches the longest possible string consisting</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">entirely of characters from the given argument. The string may be empty, so</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">this pattern always succeeds.</span>

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Null or Span (always succeeds)</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">[NOT in SPITBOL]</span>

<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">NSpan</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> <span style="color: #000000;">c</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">NSpan</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">CharacterSet</span>&amp; <span style="color: #000000;">set</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">NSpan</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">str</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">NSpan</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span> *<span style="color: #000000;">str</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">NSpan</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">StringGetter</span>&amp;);

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Pos</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Constructs a pattern that matches the null string if exactly count characters</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">have already been matched, and otherwise fails.</span>

<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Pos</span>(<span style="color: #0000ff;">Natural</span> <span style="color: #000000;">count</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Pos</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">UnsignedGetter</span>&amp;);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Pos</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Natural</span> *<span style="color: #000000;">ptr</span>);

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Rem</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Constructs a pattern that always succeeds, matching the remaining unmatched</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">characters in the pattern.</span>

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">SPITBOL: REM</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">C++: Rem</span>

<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Rem</span>();

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Rpos</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Constructs a pattern that matches the null string if exactly count characters</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">remain to be matched in the string, and otherwise fails.</span>

<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Rpos</span>(<span style="color: #0000ff;">Natural</span> <span style="color: #000000;">count</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Rpos</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">UnsignedGetter</span>&amp;);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Rpos</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Natural</span> *<span style="color: #000000;">ptr</span>);

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Rtab</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Constructs a pattern that matches from the current location until exactly</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">count characters remain to be matched in the string. The pattern fails if</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">fewer than count characters remain to be matched.</span>

<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Rtab</span>(<span style="color: #0000ff;">Natural</span> <span style="color: #000000;">count</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Rtab</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">UnsignedGetter</span>&amp;);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Rtab</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Natural</span> *<span style="color: #000000;">ptr</span>);

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Setcur</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Constructs a pattern that matches the null string, and assigns the current</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">cursor position in the string to var. This value is the number of</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">characters matched so far. So it is zero at the start of the match.</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">SPITBOL: unary "@"</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">C++: Setcur</span>

<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Setcur</span>(<span style="color: #0000ff;">Natural</span> &amp;<span style="color: #000000;">var</span>);

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Span</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Constructs a pattern that matches the longest possible string consisting</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">entirely of characters from the given argument. The string cannot be empty ,</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">so the pattern fails if the current character is not one of the characters in</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">str.</span>

<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Span</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Character</span> <span style="color: #000000;">c</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Span</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">CharacterSet</span>&amp; <span style="color: #000000;">set</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Span</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span>&amp; <span style="color: #000000;">str</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Span</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">string</span> *<span style="color: #000000;">str</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Span</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">StringGetter</span>&amp;);

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Succeed</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Constructs a pattern that succeeds matching null, both on the first attempt,</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">and on any rematch attempt, i.e. it is equivalent to an infinite alternation</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">of null strings.</span>

<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Succeed</span>();

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Tab</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Constructs a pattern that from the current location until count characters</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">have been matched. The pattern fails if more than count characters have</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">already been matched.</span>

<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Tab</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Natural</span> <span style="color: #000000;">count</span>);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Tab</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">UnsignedGetter</span>&amp;);
<span style="color: #0000ff;">Pattern</span> <span style="color: #00008b; font-weight: bold;">Tab</span>(<span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Natural</span> *<span style="color: #000000;">ptr</span>);

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">/// </span><span style="color: #912cee;">Pattern Matching Operations</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">The Match function performs an actual pattern matching operation.  The</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">versions with two parameters perform a match without modifying the subject</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">string and return a bool result indicating if the match is successful or</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">not.</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Note that pattern assignment functions in the pattern may generate side</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">effects, so these functions are not necessarily pure.</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Pattern::anchor</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">//   </span><span style="color: #912cee;">This flag can be set to cause all subsequent pattern matches to operate in</span>
<span style="color: #912cee; font-weight: bold;">//   </span><span style="color: #912cee;">anchored mode. In anchored mode, no attempt is made to move the anchor</span>
<span style="color: #912cee; font-weight: bold;">//   </span><span style="color: #912cee;">point, so that if the match succeeds it must succeed starting at the first</span>
<span style="color: #912cee; font-weight: bold;">//   </span><span style="color: #912cee;">character. Note that the effect of anchored mode may be achieved in</span>
<span style="color: #912cee; font-weight: bold;">//   </span><span style="color: #912cee;">individual pattern matches by using Fence or Pos(0) at the start of the</span>
<span style="color: #912cee; font-weight: bold;">//   </span><span style="color: #912cee;">pattern.</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">//   </span><span style="color: #912cee;">In an unanchored match, which is the default, successive attempts are made</span>
<span style="color: #912cee; font-weight: bold;">//   </span><span style="color: #912cee;">to match the given pattern at each character of the subject string until a</span>
<span style="color: #912cee; font-weight: bold;">//   </span><span style="color: #912cee;">match succeeds, or until all possibilities have failed.</span>

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">/// </span><span style="color: #912cee;">Debugging Routines</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">Debugging pattern matching operations can often be quite complex, since there</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">is no obvious way to trace the progress of the match.  The declarations in</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">this section provide some debugging assistance.</span>

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Pattern::debug flag</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">The Pattern::debug flag can be provided to the Match functions to generate</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">debugging information. The debugging output is a full trace of the actions of</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">the pattern matcher, written to cout. The level of this information is</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">intended to be comprehensible at the abstract level of this package</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">declaration. However, note that the use of this switch often generates large</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">amounts of output.</span>

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Dump pattern (as table) to std::ostream</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">This procedure writes information about the pattern to the std::ostream</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">provided.  The format of this information is keyed to the internal data</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">structures used to implement patterns. The information provided by Dump is</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">thus more precise than that yielded by Image, but is also a bit more obscure</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">(i.e. it cannot be interpreted solely in terms of this spec, you have to know</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">something about the data structures).</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">void Pattern::dump(std::ostream &amp;) const;</span>

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">///  </span><span style="color: #912cee;">Write pattern to std::ostream</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">----------------------------------------------------------------------------</span>
<span style="color: #912cee; font-weight: bold;">//</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">This output operator writes a string representation of the pattern that</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">corresponds to the syntax needed to create the given pattern using the</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">functions in this package. The form of this string is such that it could</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">actually be compiled and evaluated to yield the required pattern except for</span>
<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">references to variables and functions.</span>
<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">ostream</span>&amp; <span style="color: #0000cd; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">&lt;&lt;</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="color: #0000ff;">ostream</span> &amp;, <span style="color: #0000cd; font-weight: bold;">const</span> <span style="color: #0000ff;">Pattern</span>&amp; <span style="color: #000000;">p</span>);

<span style="color: #912cee; font-weight: bold;">// </span><span style="color: #912cee;">-----------------------------------------------------------------------------</span>
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2016-08-23 Tue 18:55</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
