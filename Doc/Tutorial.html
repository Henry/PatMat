<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title><b>PatMat: SPITBOL-like pattern construction and matching in C++</b></title>
<!-- 2016-08-21 Sun 14:48 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title"><b>PatMat: SPITBOL-like pattern construction and matching in C++</b></h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Pattern Matching Tutorial</a>
<ul>
<li><a href="#sec-1-1">1.1. Concatenation and Alternation</a></li>
<li><a href="#sec-1-2">1.2. Moving the Start Point</a></li>
<li><a href="#sec-1-3">1.3. Other Pattern Elements</a>
<ul>
<li><a href="#sec-1-3-1">1.3.1. Arb</a></li>
<li><a href="#sec-1-3-2">1.3.2. Abort</a></li>
<li><a href="#sec-1-3-3">1.3.3. Fail</a></li>
<li><a href="#sec-1-3-4">1.3.4. Fence</a></li>
<li><a href="#sec-1-3-5">1.3.5. Rem</a></li>
<li><a href="#sec-1-3-6">1.3.6. Succeed</a></li>
</ul>
</li>
<li><a href="#sec-1-4">1.4. Pattern Construction Functions</a>
<ul>
<li><a href="#sec-1-4-1">1.4.1. Any(S)</a></li>
<li><a href="#sec-1-4-2">1.4.2. Arbno(P)</a></li>
<li><a href="#sec-1-4-3">1.4.3. Bal(Open, Close)</a></li>
<li><a href="#sec-1-4-4">1.4.4. Break(S)</a></li>
<li><a href="#sec-1-4-5">1.4.5. BreakX(S)</a></li>
<li><a href="#sec-1-4-6">1.4.6. Fence(P)</a></li>
<li><a href="#sec-1-4-7">1.4.7. Len(N)</a></li>
<li><a href="#sec-1-4-8">1.4.8. NotAny(S)</a></li>
<li><a href="#sec-1-4-9">1.4.9. NSpan(S)</a></li>
<li><a href="#sec-1-4-10">1.4.10. Pos(N)</a></li>
<li><a href="#sec-1-4-11">1.4.11. Rpos(N)</a></li>
<li><a href="#sec-1-4-12">1.4.12. Rtab(N)</a></li>
<li><a href="#sec-1-4-13">1.4.13. Tab(N)</a></li>
<li><a href="#sec-1-4-14">1.4.14. Span(S)</a></li>
</ul>
</li>
<li><a href="#sec-1-5">1.5. Recursive Pattern Matching</a></li>
<li><a href="#sec-1-6">1.6. Pattern Assignment Operations</a></li>
<li><a href="#sec-1-7">1.7. Deferred Matching</a></li>
<li><a href="#sec-1-8">1.8. Deferred Replacement</a></li>
<li><a href="#sec-1-9">1.9. Examples of Pattern Matching</a></li>
<li><a href="#sec-1-10">1.10. Correspondence with Pattern Matching in SPITBOL</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Example Code</a></li>
<li><a href="#sec-3">3. Pattern Functions and Operators</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Pattern Matching Tutorial</h2>
<div class="outline-text-2" id="text-1">
<p>
A pattern matching operation (a call to one of the <code>Match</code> functions) takes a
subject string and a pattern, and optionally a replacement string. The
replacement string option is only allowed if the subject is a variable.
</p>

<p>
The pattern is matched against the subject string, and either the match fails,
or it succeeds matching a contiguous sub-string. If a replacement string is
specified, then the subject string is modified by replacing the matched
sub-string with the given replacement.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Concatenation and Alternation</h3>
<div class="outline-text-3" id="text-1-1">
<p>
A pattern consists of a series of pattern elements. The pattern is built up
using either the concatenation operator:
</p>
<div class="org-src-container">

<pre class="src src-c++">A &amp; B
</pre>
</div>
<p>
which means match <code>A</code> followed immediately by matching B, or the alternation
operator:
</p>
<div class="org-src-container">

<pre class="src src-c++">A | B
</pre>
</div>
<p>
which means first attempt to match <code>A</code>, and then if that does not succeed,
match <code>B</code>.
</p>

<p>
There is full backtracking, which means that if a given pattern element
fails to match, then previous alternatives are matched.  For example if we
have the pattern:
</p>
<div class="org-src-container">

<pre class="src src-c++">(A | B) &amp; (C | D) &amp; (E | F)
</pre>
</div>
<p>
First we attempt to match <code>A</code>, if that succeeds, then we go on to try to
match <code>C</code>, and if that succeeds, we go on to try to match <code>E</code>. If <code>E</code> fails,
then we try <code>F</code>. If <code>F</code> fails, then we go back and try matching <code>D</code> instead
of <code>C</code>. Let's make this explicit using a specific example, and introducing
the simplest kind of pattern element, which is a literal string. The meaning
of this pattern element is simply to match the characters that correspond to
the string characters. Now let's rewrite the above pattern form with
specific string literals as the pattern elements:
</p>
<div class="org-src-container">

<pre class="src src-c++">("ABC" | "AB") &amp; ("DEF" | "CDE") &amp; ("GH" | "IJ")
</pre>
</div>
<p>
The following strings will be attempted in sequence:
</p>
<div class="org-src-container">

<pre class="src src-c++">ABC . DEF . GH
ABC . DEF . IJ
ABC . CDE . GH
ABC . CDE . IJ
AB . DEF . GH
AB . DEF . IJ
AB . CDE . GH
AB . CDE . IJ
</pre>
</div>
<p>
Here we use the dot simply to separate the pieces of the string matched by
the three separate elements.
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Moving the Start Point</h3>
<div class="outline-text-3" id="text-1-2">
<p>
A pattern is not required to match starting at the first character of the
string, and is not required to match to the end of the string.  The first
attempt does indeed attempt to match starting at the first character of the
string, trying all the possible alternatives. But if all alternatives fail,
then the starting point of the match is moved one character, and all
possible alternatives are attempted at the new anchor point.
</p>

<p>
The entire match fails only when every possible starting point has been
attempted. As an example, suppose that we had the subject string
</p>
<div class="org-src-container">

<pre class="src src-c++">"ABABCDEIJKL"
</pre>
</div>
<p>
matched using the pattern in the previous example:
</p>
<div class="org-src-container">

<pre class="src src-c++">("ABC" | "AB") &amp; ("DEF" | "CDE") &amp; ("GH" | "IJ")
</pre>
</div>
<p>
would succeed, after two anchor point moves:
</p>
<div class="org-src-container">

<pre class="src src-c++">"ABABCDEIJKL"
   ^^^^^^^
   matched
   section
</pre>
</div>
<p>
This mode of pattern matching is called the unanchored mode. It is also
possible to put the pattern matcher into anchored mode by providing the
optional flag Pattern::anchor to the <code>Match</code> function.  This will cause the
match to be performed in anchored mode, where the match is required to
start at the first character.
</p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Other Pattern Elements</h3>
<div class="outline-text-3" id="text-1-3">
<p>
In addition to strings (or single characters), there are many special
pattern elements that correspond to special predefined alternations:
</p>
</div>
<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> Arb</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
Matches any string.  First it matches the null string, and then on a
subsequent failure, matches one character, and then two characters, and so
on. It only fails if the entire remaining string is matched.
</p>
</div>
</div>
<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> Abort</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Immediately aborts the entire pattern match, signalling failure. This is a
specialized pattern element, which is useful in conjunction with some of
the special pattern elements that have side effects.
</p>
</div>
</div>
<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3"><span class="section-number-4">1.3.3</span> Fail</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
The null alternation. Matches no possible strings, so it always signals
failure. This is a specialized pattern element, which is useful in
conjunction with some of the special pattern elements that have side
effects.
</p>
</div>
</div>
<div id="outline-container-sec-1-3-4" class="outline-4">
<h4 id="sec-1-3-4"><span class="section-number-4">1.3.4</span> Fence</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
Matches the null string at first, and then if a failure causes
alternatives to be sought, aborts the match (like a <code>Cancel</code>). Note that
using <code>Fence</code> at the start of a pattern has the same effect as matching in
anchored mode.
</p>
</div>
</div>
<div id="outline-container-sec-1-3-5" class="outline-4">
<h4 id="sec-1-3-5"><span class="section-number-4">1.3.5</span> Rem</h4>
<div class="outline-text-4" id="text-1-3-5">
<p>
Matches from the current point to the last character in the string. This
is a specialized pattern element, which is useful in conjunction with some
of the special pattern elements that have side effects.
</p>
</div>
</div>
<div id="outline-container-sec-1-3-6" class="outline-4">
<h4 id="sec-1-3-6"><span class="section-number-4">1.3.6</span> Succeed</h4>
<div class="outline-text-4" id="text-1-3-6">
<p>
Repeatedly matches the null string.  It is equivalent to the alternation
</p>
<div class="org-src-container">

<pre class="src src-c++">("" | "" | "" ....).
</pre>
</div>
<p>
This is a special pattern element, which is useful in conjunction with
some of the special pattern elements that have side effects.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Pattern Construction Functions</h3>
<div class="outline-text-3" id="text-1-4">
<p>
The following functions construct additional pattern elements
</p>
</div>
<div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1"><span class="section-number-4">1.4.1</span> Any(S)</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
Where <code>S</code> is a string, matches a single character that is any one of the
characters in <code>S</code>. Fails if the current character is not one of the given
set of characters.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2"><span class="section-number-4">1.4.2</span> Arbno(P)</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
Where <code>P</code> is any pattern, matches any number of instances of the pattern,
starting with zero occurrences. It is thus equivalent to
</p>
<div class="org-src-container">

<pre class="src src-c++">("" | (P &amp; ("" | (P &amp; ("" ....)))).
</pre>
</div>
<p>
The pattern <code>P</code> may contain any number of
pattern elements including the use of alternatiion and concatenation.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-3" class="outline-4">
<h4 id="sec-1-4-3"><span class="section-number-4">1.4.3</span> Bal(Open, Close)</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
Matches a non-empty string that is parentheses balanced with respect to
characters <code>Open</code> and <code>Close</code>.  Examples of balanced strings are "ABC",
"A((B)C)", and "A(B)C(D)E".  <code>Bal(Open, Close)</code> matches the shortest
possible balanced string on the first attempt, and if there is a
subsequent failure, attempts to extend the string.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-4" class="outline-4">
<h4 id="sec-1-4-4"><span class="section-number-4">1.4.4</span> Break(S)</h4>
<div class="outline-text-4" id="text-1-4-4">
<p>
Where <code>S</code> is a string, matches a string of zero or more characters up to
but not including a break character that is one of the characters given in
the string <code>S</code>.  Can match the null string, but cannot match the last
character in the string, since a break character is required to be
present.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-5" class="outline-4">
<h4 id="sec-1-4-5"><span class="section-number-4">1.4.5</span> BreakX(S)</h4>
<div class="outline-text-4" id="text-1-4-5">
<p>
Where <code>S</code> is a string, behaves exactly like <code>Break(S)</code> when it first
matches, but if a string is successfully matched, then a susequent failure
causes an attempt to extend the matched string.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-6" class="outline-4">
<h4 id="sec-1-4-6"><span class="section-number-4">1.4.6</span> Fence(P)</h4>
<div class="outline-text-4" id="text-1-4-6">
<p>
Where <code>P</code> is a pattern, attempts to match the pattern <code>P</code> including trying
all possible alternatives of <code>P</code>. If none of these alternatives succeeds,
then the <code>Fence</code> pattern fails. If one alternative succeeds, then the
pattern match proceeds, but on a subsequent failure, no attempt is made to
search for alternative matches of <code>P</code>. The pattern <code>P</code> may contain any
number of pattern elements including the use of alternatiion and
concatenation.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-7" class="outline-4">
<h4 id="sec-1-4-7"><span class="section-number-4">1.4.7</span> Len(N)</h4>
<div class="outline-text-4" id="text-1-4-7">
<p>
Where <code>N</code> is a natural number, matches the given number of characters. For
example, <code>Len(10)</code> matches any string that is exactly 10 characters long.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-8" class="outline-4">
<h4 id="sec-1-4-8"><span class="section-number-4">1.4.8</span> NotAny(S)</h4>
<div class="outline-text-4" id="text-1-4-8">
<p>
Where <code>S</code> is a string, matches a single character that is not one of the
characters of <code>S</code>. Fails if the current characer is one of the given set
of characters.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-9" class="outline-4">
<h4 id="sec-1-4-9"><span class="section-number-4">1.4.9</span> NSpan(S)</h4>
<div class="outline-text-4" id="text-1-4-9">
<p>
Where <code>S</code> is a string, matches a string of zero or more characters that is
among the characters given in the string. Always matches the longest
possible such string.  Always succeeds, since it can match the null
string.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-10" class="outline-4">
<h4 id="sec-1-4-10"><span class="section-number-4">1.4.10</span> Pos(N)</h4>
<div class="outline-text-4" id="text-1-4-10">
<p>
Where <code>N</code> is a natural number, matches the null string if exactly <code>N</code>
characters have been matched so far, and otherwise fails.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-11" class="outline-4">
<h4 id="sec-1-4-11"><span class="section-number-4">1.4.11</span> Rpos(N)</h4>
<div class="outline-text-4" id="text-1-4-11">
<p>
Where <code>N</code> is a natural number, matches the null string if exactly <code>N</code>
characters remain to be matched, and otherwise fails.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-12" class="outline-4">
<h4 id="sec-1-4-12"><span class="section-number-4">1.4.12</span> Rtab(N)</h4>
<div class="outline-text-4" id="text-1-4-12">
<p>
Where <code>N</code> is a natural number, matches characters from the current
position until exactly <code>N</code> characters remain to be matched in the
string. Fails if fewer than <code>N</code> unmatched characters remain in the string.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-13" class="outline-4">
<h4 id="sec-1-4-13"><span class="section-number-4">1.4.13</span> Tab(N)</h4>
<div class="outline-text-4" id="text-1-4-13">
<p>
Where <code>N</code> is a natural number, matches characters from the current
position until exactly <code>N</code> characters have been matched in all. Fails if
more than <code>N</code> characters have already been matched.
</p>
</div>
</div>
<div id="outline-container-sec-1-4-14" class="outline-4">
<h4 id="sec-1-4-14"><span class="section-number-4">1.4.14</span> Span(S)</h4>
<div class="outline-text-4" id="text-1-4-14">
<p>
Where <code>S</code> is a string, matches a string of one or more characters that is
among the characters given in the string. Always matches the longest
possible such string.  Fails if the current character is not one of the
given set of characters.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> Recursive Pattern Matching</h3>
<div class="outline-text-3" id="text-1-5">
<p>
The plus operator <code>(+P)</code> where <code>P</code> is a pattern variable, creates a
recursive pattern that will, at pattern matching time, follow the pointer to
obtain the referenced pattern, and then match this pattern. This may be used
to construct recursive patterns. Consider for example:
</p>
<div class="org-src-container">

<pre class="src src-c++">P = ("A" | ("B" &amp; (+P)))
</pre>
</div>
<p>
On the first attempt, this pattern attempts to match the string "A".  If
this fails, then the alternative matches a "B", followed by an attempt to
match <code>P</code> again. This second attempt first attempts to match "A", and so
on. The result is a pattern that will match a string of <code>B</code>'s followed by a
single <code>A</code>.
</p>

<p>
This particular example could simply be written as <code>(NSpan('B') &amp; 'A')</code>, but
the use of recursive patterns in the general case can construct complex
patterns which could not otherwise be built.
</p>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> Pattern Assignment Operations</h3>
<div class="outline-text-3" id="text-1-6">
<p>
In addition to the overall result of a pattern match, which indicates
success or failure, it is often useful to be able to keep track of the
pieces of the subject string that are matched by individual pattern
elements, or subsections of the pattern.
</p>

<p>
The pattern assignment operators allow this capability. The first form is
the immediate assignment:
</p>
<div class="org-src-container">

<pre class="src src-c++">P % S
</pre>
</div>
<p>
Here <code>P</code> is an arbitrary pattern, and <code>S</code> is a variable of type
<code>string</code> that will be set to the sub-string matched by P. This
assignment happens during pattern matching, so if <code>P</code> matches more than
once, then the assignment happens more than once.
</p>

<p>
The deferred assignment operation:
</p>
<div class="org-src-container">

<pre class="src src-c++">P * S
</pre>
</div>
<p>
avoids these multiple assignments by deferring the assignment to the end of
the match. If the entire match is successful, and if the pattern <code>P</code> was
part of the successful match, then at the end of the matching operation the
assignment to <code>S</code> of the string matching <code>P</code> is performed.
</p>

<p>
The cursor assignment operation:
</p>
<div class="org-src-container">

<pre class="src src-c++">Setcur(N)
</pre>
</div>
<p>
assigns the current cursor position to the natural variable <code>N</code>. The cursor
position is defined as the count of characters that have been matched so far
(including any start point moves).
</p>

<p>
Finally the operations <code>%</code> and <code>*</code> may be used with values of type
<code>ostream</code>. The effect is to do a <code>&lt;&lt;</code> operation of the matched
sub-string. These are particularly useful in debugging pattern matches.
</p>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> Deferred Matching</h3>
<div class="outline-text-3" id="text-1-7">
<p>
The pattern construction functions (such as <code>Len</code> and <code>Any</code>) all permit the
use of pointers to natural or string values, or functions that return
natural or string values. These forms cause the actual value to be obtained
at pattern matching time. This allows interesting possibilities for
constructing dynamic patterns as illustrated in the examples section.
</p>

<p>
In addition the <code>(+S)</code> operator may be used where <code>S</code> is a pointer to
string or function returning string, with a similar deferred effect.
</p>

<p>
A special use of deferred matching is the construction of predicate
functions. The element <code>(+P)</code> where <code>P</code> is an access to a function that
returns a <code>bool</code> value, causes the function to be called at the time the
element is matched. If the function returns <code>true</code>, then the null string is
matched, if the function returns <code>false</code>, then failure is signalled and
previous alternatives are sought.
</p>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> Deferred Replacement</h3>
<div class="outline-text-3" id="text-1-8">
<p>
The simple model given for pattern replacement (where the matched sub-string
is replaced by the string given as the third argument to <code>Match</code>) works fine
in simple cases, but this approach does not work in the case where the
expression used as the replacement string is dependent on values set by the
match.
</p>

<p>
For example, suppose we want to find an instance of a parenthesized
character, and replace the parentheses with square brackets. At first glance
it would seem that:
</p>
<div class="org-src-container">

<pre class="src src-c++">Match(subject, '(' &amp; Len(1) % c &amp; ')', '[' &amp; c &amp; ']');
</pre>
</div>
<p>
would do the trick, but that does not work, because the third argument to
Match gets evaluated too early, before the call to Match, and before the
pattern match has had a chance to set <code>c</code>.
</p>

<p>
To solve this problem we provide the deferred replacement capability.  With
this approach, which of course is only needed if the pattern involved has
side effects, is to do the match in two stages. The call to <code>Match</code> sets a
pattern result in a variable of type <code>MatchRes</code>, and then a subsequent
assignment operation uses this <code>MatchRes</code> object to perform the required
replacement.
</p>

<p>
Using this approach, we can now write the above operation properly in a
manner that will work:
</p>
<div class="org-src-container">

<pre class="src src-c++">string c;
MatchRes m(c);
...
Match(m, '(' &amp; Len(1) % c &amp; ')');
m = '[' + c + ']';
</pre>
</div>
<p>
An assignment after a failed match has no effect. Note that
<code>MatchRes m</code> should not be modified between the calls as it stores the start
and end of the matched sub-string.
</p>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> Examples of Pattern Matching</h3>
<div class="outline-text-3" id="text-1-9">
<p>
First a simple example of the use of pattern replacement to remove a line
number from the start of a string. We assume that the line number has the
form of a string of decimal digits followed by a period, followed by one or
more spaces.
</p>
<div class="org-src-container">

<pre class="src src-c++">const Pattern digs = Span("0123456789");
const Pattern lNum = Pos(0U) &amp; digs &amp; '.' &amp; Span(' ');
</pre>
</div>
<p>
Now to use this pattern we simply do a match with a replacement:
</p>
<div class="org-src-container">

<pre class="src src-c++">Match(line, lNum, "");
</pre>
</div>
<p>
which replaces the line number by the null string. Note that it is also
possible to use an <code>CharacterSet</code> value as an argument to <code>Span</code> and similar
functions, and in particular all the useful constants 'in
<code>CharacterSet::CharacterSets</code> are available. This means that we could define
<code>Digs</code> as:
</p>
<div class="org-src-container">

<pre class="src src-c++">const Pattern digs = Span(CharacterSets::digit);
</pre>
</div>
<p>
The style we use here, of defining constant patterns and then using them is
typical.  It is possible to build up patterns dynamically, but it is usually
more efficient to build them in pieces in advance using constant
declarations.  Note in particular that although it is possible to construct
a pattern directly as an argument for the Match routine, it is much more
efficient to preconstruct the pattern as we did in this example.
</p>

<p>
Now let's look at the use of pattern assignment to break a string into
sections. Suppose that the input string has two unsigned int decimal integers,
separated by spaces or a comma, with spaces allowed anywhere. Then we can
isolate the two numbers with the following pattern:
</p>
<div class="org-src-container">

<pre class="src src-c++">string num1, num2;
const Pattern blank = NSpan(' ');
const Pattern num = Span("0123456789");
const Pattern nums = blank &amp; num % num1 &amp; Span(" ,") &amp; num % num2;
Match(" 124, 257 ", nums);
</pre>
</div>
<p>
The match operation <code>Match(" 124, 257 ", nums)</code> would assign the string
<code>124</code> to <code>num1</code> and the string <code>257</code> to <code>num2</code>.
</p>

<p>
Now let's see how more complex elements can be built from the set of
primitive elements. The following pattern matches strings that have the
syntax of Ada 95 literals:
</p>
<div class="org-src-container">

<pre class="src src-c++">const Pattern digs  = Span(CharacterSets::digit);
const Pattern uDigs = digs &amp; Arbno('_' &amp; digs);

const Pattern eDig  = Span(CharacterSets::xdigit);
const Pattern ueDdig = eDig &amp; Arbno('_' &amp; eDig);

const Pattern bNum  = uDigs &amp; '#' &amp; ueDig &amp; '#';
</pre>
</div>
<p>
A match against <code>bNum</code> will now match the desired strings, <i>e.g.</i> it will
match <code>16#123_abc#</code>, but not <code>a#b#</code>. However, this pattern is not quite
complete, since it does not allow colons to replace the pound signs. The
following is more complete:
</p>
<div class="org-src-container">

<pre class="src src-c++">const Pattern bChar = Any("#:");
const Pattern bNum  = uDigs &amp; bChar &amp; ueDig &amp; bChar;
</pre>
</div>
<p>
but that is still not quite right, since it allows <code>#</code> and <code>:</code> to be mixed,
and they are supposed to be used consistently.  We solve this by using a
deferred match.
</p>
<div class="org-src-container">

<pre class="src src-c++">string temp;
const Pattern bNum = uDigs &amp; bChar % temp &amp; ueDdig &amp; (+temp)
</pre>
</div>
<p>
Here the first instance of the base character is stored in <code>temp</code>, and
then later in the pattern we rematch the value that was assigned.
</p>

<p>
For an example of a recursive pattern, let's define a pattern that is like
the built in <code>Bal(Open, Close)</code>, but the string matched is balanced with
respect to square brackets OR curly brackets.
</p>

<p>
The language for such strings might be defined in extended BNF as
</p>
<div class="org-src-container">

<pre class="src src-c++">ELEMENT ::= &lt;any character other than [] or {}&gt;
           | '[' BALANCED_STRING ']'
           | '{' BALANCED_STRING '}'

BALANCED_STRING ::= ELEMENT {ELEMENT}
</pre>
</div>
<p>
Here we use <code>{}</code> to indicate zero or more occurrences of a term, as is
common practice in extended BNF. Now we can translate the above BNF into
recursive patterns as follows:
</p>
<div class="org-src-container">

<pre class="src src-c++">Pattern balancedString;

Pattern element =
    NotAny("[]{}")
  | ('[' &amp; (+balancedString) &amp; ']')
  | ('{' &amp; (+balancedString) &amp; '}');

balancedString = element &amp; Arbno(element);
</pre>
</div>
<p>
Note the important use of <code>+</code> here to refer to a pattern not yet defined.
Note also that we use assignments precisely because we cannot refer to as
yet undeclared variables in initializations.
</p>

<p>
Now that this pattern is constructed, we can use it as though it were a new
primitive pattern element, and for example, the match:
</p>
<div class="org-src-container">

<pre class="src src-c++">Match("xy[ab{cd}]", balancedString % cout &amp; Fail());
</pre>
</div>
<p>
will generate the output:
</p>
<div class="org-src-container">

<pre class="src src-c++">x
xy
xy[ab{cd}]
y
y[ab{cd}]
[ab{cd}]
a
ab
ab{cd}
b
b{cd}
{cd}
c
cd
d
</pre>
</div>
<p>
Note that the function of the fail here is simply to force the pattern
Balanced_String to match all possible alternatives. Studying the operation
of this pattern in detail is highly instructive.
</p>

<p>
Finally we give a rather elaborate example of the use of deferred matching.
The following declarations build up a pattern which will find the longest
string of decimal digits in the subject string.
</p>
<div class="org-src-container">

<pre class="src src-c++">class MaxLen
:
    public BoolInterface
{
    const string&amp; cur_;
    const string&amp; max_;

    public:

        MaxLen(const string&amp; cur, const string&amp; max)
        :
            cur_(cur),
            max_(max)
        {}

        bool get()
        {
            return cur_.size() &gt; max_.size();
        }
};

.
.
.

string cur, max;
unsigned int loc;

MaxLen GtS(cur, max);

const CharacterSet&amp; digit = CharacterSets::digit;
const Pattern digits = Span(digit);

const Pattern find =
    "" % max &amp; Fence()         &amp; // initialize max to null
    BreakX(digit)              &amp; // scan looking for digits
    ((digits % cur             &amp; // assign next string to cur
     (+GtS)                    &amp; // check cur.size() &gt; max.size()
     Setcur(loc))                // if so, save location
             % max)            &amp; // and assign to max
    Fail();                      // seek all alternatives
</pre>
</div>
<p>
As we see from the comments here, complex patterns like this take on aspects
of sequential programs. In fact they are sequential programs with general
backtracking. In this pattern, we first use a pattern assignment that
matches null and assigns it to <code>max</code>, so that it is initialized for the new
match. Now <code>BreakX</code> scans to the next digit. <code>Arb</code> would do here, but
<code>BreakX</code> will be more efficient.  Once we have found a digit, we scan out
the longest string of digits with <code>Span</code>, and assign it to <code>cur</code>. The
deferred call to <code>GtS.get()</code> tests if the string we assigned to <code>cur</code> is
the longest so far. If not, then failure is signalled, and we seek
alternatives (this means that <code>BreakX</code> will extend and look for the next
digit string).  If the call to <code>GtS.get()</code> succeeds then the matched
string is assigned as the largest string so far into <code>max</code> and its location
is saved in <code>loc</code>. Finally <code>Fail</code> forces the match to fail and seek
alternatives, so that the entire string is searched.
</p>

<p>
If the pattern <code>find</code> is matched against a string, the variable <code>max</code> at the
end of the pattern will have the longest string of digits, and <code>loc</code> will be
the starting character location of the string. For example,
<code>Match("ab123cd4657ef23", find)</code> will assign "4657" to <code>max</code> and <code>11</code> to
<code>loc</code> (indicating that the string ends with the eleventh character of the
string).
</p>
</div>
</div>

<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10"><span class="section-number-3">1.10</span> Correspondence with Pattern Matching in SPITBOL</h3>
<div class="outline-text-3" id="text-1-10">
<p>
Generally the C++ syntax and names correspond closely to SPITBOL syntax for
pattern matching construction.
</p>

<p>
The basic pattern construction operators are renamed as follows:
</p>
<div class="org-src-container">

<pre class="src src-c++">SPITBOL     C++
(space)      &amp;
   |         | (Or for Character)
   $         %
   .         *
   *         +
</pre>
</div>
<p>
The C++ operators were chosen so that the relative precedences of these
operators corresponds to that of the SPITBOL operators, but as always, the
use of parentheses is advisable to clarify.
</p>

<p>
The pattern construction operators all have similar names.
</p>

<p>
The actual pattern matching syntax is modified in C++ as follows:
</p>
<div class="org-src-container">

<pre class="src src-c++">SPITBOL      C++
x y          Match(x, y);
x y = repl   Match(x, y, repl);
</pre>
</div>
<p>
and pattern failure is indicated by returning a <code>bool</code> result from the
<code>Match</code> function (<code>true</code> for success, <code>false</code> for failure).
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Example Code</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">

<pre class="src src-c++">#include &lt;string&gt;
#include &lt;iostream&gt;

#include "Pattern.H"

using namespace PatMat;
using namespace std;

class MaxLen
:
    public BoolInterface
{
    const string&amp; cur_;
    const string&amp; max_;

    public:

        MaxLen(const string&amp; cur, const string&amp; max)
        :
            cur_(cur),
            max_(max)
        {}

        bool get()
        {
            return cur_.size() &gt; max_.size();
        }
};


int main()
{
    {
        MatchRes m("Change brackets around character (a)");
        string c;
        Match(m, '(' &amp; Len(1) % c &amp; ')');
        m = '[' + c + ']';
        cout &lt;&lt; m &lt;&lt; endl;
    }
    {
        //const Pattern digs = Span("0123456789");
        const Pattern digs = Span(CharacterSets::digit);
        const Pattern lNum = Pos(0U) &amp; digs &amp; '.' &amp; Span(' ');
        string line("258. Words etc.");
        Match(line, lNum, "");
        cout &lt;&lt; line &lt;&lt; endl;
    }
    {
        string num1, num2;
        const Pattern blank = NSpan(' ');
        const Pattern num = Span("0123456789");
        const Pattern nums = blank &amp; num % num1 &amp; Span(" ,") &amp; num % num2;
        Match(" 124, 257 ", nums);
        cout &lt;&lt; "num1 = " &lt;&lt; num1 &lt;&lt; "; num2 = " &lt;&lt; num2 &lt;&lt; endl;
    }
    {
        const Pattern digs  = Span(CharacterSets::digit);
        const Pattern uDigs = digs &amp; Arbno('_' &amp; digs);
        const Pattern eDig  = Span(CharacterSets::xdigit);
        const Pattern ueDig = eDig &amp; Arbno('_' &amp; eDig);
        const Pattern bChar = Any("#:");
        string temp;
        const Pattern bNum = uDigs &amp; bChar % temp &amp; ueDig &amp; (+temp);
        const string subject("16#123_abc#");
        if (Match(subject, bNum)) cout &lt;&lt; "Matched " &lt;&lt; subject &lt;&lt; endl;
    }
    {
        Pattern balancedString;

        Pattern element =
            NotAny("[]{}")
          | ('[' &amp; (+balancedString) &amp; ']')
          | ('{' &amp; (+balancedString) &amp; '}');

        balancedString = element &amp; Arbno(element);

        cout &lt;&lt; Match("xy[ab{cd}]", balancedString % cout &amp; Fail()) &lt;&lt; endl;
    }
    {
        string cur, max;
        unsigned int loc;

        MaxLen GtS(cur, max);

        const CharacterSet&amp; digit = CharacterSets::digit;
        const Pattern digits = Span(digit);

        const Pattern find =
            "" % max &amp; Fence()         &amp; // initialize max to null
            BreakX(digit)              &amp; // scan looking for digits
            ((digits % cur             &amp; // assign next string to cur
             (+GtS)                    &amp; // check cur.size() &gt; max.size()
             Setcur(loc))                // if so, save location
                     % max)            &amp; // and assign to max
            Fail();                      // seek all alternatives

        Match("ab123cd4657ef23", find);
        cout&lt;&lt; "max = " &lt;&lt; max &lt;&lt; "; loc = " &lt;&lt; loc &lt;&lt; endl;
    }

    return 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Pattern Functions and Operators</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">

<pre class="src src-c++">// ----------------------------------------------------------------------------
/// Pattern functions and operators
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
///  Abort
// ----------------------------------------------------------------------------
// Constructs a pattern that immediately aborts the entire match
Pattern Abort();

// ----------------------------------------------------------------------------
///  Alternation
// ----------------------------------------------------------------------------
// Creates a pattern that will first try to match l and then on a subsequent
// failure, attempts to match r instead.
// Matches l followed by r
// SPITBOL: binary "|"
// C++: binary "|"

Pattern operator|(const std::string&amp; l, const Pattern&amp; r);
Pattern operator|(const Character *l, const Pattern&amp; r);
Pattern operator|(const Pattern&amp; l, const std::string&amp; r);
Pattern operator|(const Pattern&amp; l, const Character *r);
Pattern operator|(const std::string&amp; l, const std::string&amp; r);
Pattern operator|(const Character *l, const std::string&amp; r);
Pattern operator|(const std::string&amp; l, const Character *r);
Pattern Or(const Character *l, const Character *r);
Pattern operator|(const Pattern&amp; l, const Pattern&amp; r);
Pattern operator|(Character l, const Pattern&amp; r);
Pattern operator|(const Pattern&amp; l, Character r);
Pattern operator|(const std::string&amp; l, Character r);
Pattern Or(const Character *l, Character r);
Pattern operator|(Character l, const std::string&amp; r);
Pattern Or(Character l, const Character *r);

// ----------------------------------------------------------------------------
/// Any
// ----------------------------------------------------------------------------
// Constructs a pattern that matches a single character that is one of the
// characters in the given argument. The pattern fails if the current character
// is not in str.

Pattern Any(Character c);
Pattern Any(const CharacterSet&amp; set);
Pattern Any(const std::string&amp; str);
Pattern Any(const std::string *str);
Pattern Any(StringInterface *);

// ----------------------------------------------------------------------------
/// Arb
// ----------------------------------------------------------------------------
//
// Constructs a pattern that will match any string. On the first attempt, the
// pattern matches a null string, then on each successive failure, it matches
// one more character, and only fails if matching the entire rest of the string.

Pattern Arb();

// ----------------------------------------------------------------------------
///  Arbno
// ----------------------------------------------------------------------------
//
// Pattern repetition. First matches null, then on a subsequent failure attempts
// to match an additional instance of the given pattern.  Equivalent to (but
// more efficient than) P &amp; ("" | (P &amp; ("" | ...

Pattern Arbno(Character c);
Pattern Arbno(const std::string&amp; str);
Pattern Arbno(const Character *str);
Pattern Arbno(const Pattern&amp; p);

// ----------------------------------------------------------------------------
///  Assignment immediately
// ----------------------------------------------------------------------------
//
// Matches P, and if the match succeeds, assigns the matched sub-string to the
// given std::string variable S. This assignment happens as soon as the
// sub-string is matched, and if the pattern P1 is matched more than once during
// the course of the match, then the assignment will occur more than once.
//
// SPITBOL: binary "$"
// C++: binary "%"

Pattern operator%(const Pattern&amp; p, std::string&amp; var);
Pattern operator%(const Pattern&amp; p, StringInterface *obj);

// ----------------------------------------------------------------------------
///  Assignment on match
// ----------------------------------------------------------------------------
//
// Like "%" above, except that the assignment happens at most once after the
// entire match is completed successfully. If the match fails, then no
// assignment takes place.
//
// SPITBOL: binary "."
// C++: binary "*"

Pattern operator*(const Pattern&amp; p, std::string&amp; var);
Pattern operator*(const Pattern&amp; p, StringInterface *obj);

// ----------------------------------------------------------------------------
///  Bal
// ----------------------------------------------------------------------------
//
// Constructs a pattern that will match any non-empty string that is parentheses
// balanced with respect to the parentheses characters open and close.
// Attempts to extend the string if a subsequent failure occurs.
Pattern Bal(const Character open, const Character close);

// ----------------------------------------------------------------------------
///  Break
// ----------------------------------------------------------------------------
//
// Constructs a pattern that matches a (possibly null) string which is
// immediately followed by a character in the given argument. This character is
// not part of the matched string. The pattern fails if the remaining characters
// to be matched do not include any of the characters in str.
Pattern Break(Character str);
Pattern Break(const CharacterSet&amp; set);
Pattern Break(const std::string&amp; str);
Pattern Break(const std::string *str);
Pattern Break(StringInterface *);

// ----------------------------------------------------------------------------
///  BreakX
// ----------------------------------------------------------------------------
//
// Like Break, but the pattern attempts to extend on a failure to find the next
// occurrence of a character in str, and only fails when the last such instance
// causes a failure.
Pattern BreakX(Character str);
Pattern BreakX(const CharacterSet&amp; set);
Pattern BreakX(const std::string&amp; str);
Pattern BreakX(const std::string *str);
Pattern BreakX(StringInterface *);

// ----------------------------------------------------------------------------
///  Concatenation operators
// ----------------------------------------------------------------------------
//
// Matches L followed by r
// SPITBOL: binary " " operator
// C++: binary "&amp;" operator

Pattern operator&amp;(const std::string&amp; l, const Pattern&amp; r);
Pattern operator&amp;(const Pattern&amp; l, const std::string&amp; r);
Pattern operator&amp;(const Pattern&amp; l, const Pattern&amp; r);
Pattern operator&amp;(Character l, const Pattern&amp; r);
Pattern operator&amp;(const Pattern&amp; l, Character r);

// ----------------------------------------------------------------------------
///  Deferred Matching
// ----------------------------------------------------------------------------
// SPITBOL: unary "*"
// C++: unary "+"

//- This function constructs a pattern which at pattern matching time will
//  access the current value of this variable, and match against the pattern
//  value.
//
//  Here p must be a Pattern variable.
//
//  DANGEROUS if Pattern lifetime longer than referenced variable!!
Pattern Defer(Pattern&amp; p);

//- This function constructs a pattern which at pattern matching time will
//  access the current value of this variable, and match against these
//  characters.
//
//  Here str must be a std::string variable.
Pattern Defer(std::string&amp; str);

//- Constructs a pattern which at pattern matching time calls the given
//  function, and then matches against the string or character value that is
//  returned by the call.
Pattern Defer(StringInterface&amp; obj);

//- Constructs a predicate pattern function that at pattern matching time calls
//  the given function. If True is returned, then the pattern matches.  If False
//  is returned, then failure is signalled.
Pattern Defer(BoolInterface&amp; obj);

inline Pattern operator+(Pattern&amp; p)
{
    return Defer(p);
}

inline Pattern operator+(std::string&amp; s)
{
    return Defer(s);
}

inline Pattern operator+(StringInterface&amp; obj)
{
    return Defer(obj);
}

inline Pattern operator+(BoolInterface&amp; obj)
{
    return Defer(obj);
}

// ----------------------------------------------------------------------------
///  Fail
// ----------------------------------------------------------------------------
// Constructs a pattern that always fails
Pattern Fail();

// ----------------------------------------------------------------------------
///  Fence
// ----------------------------------------------------------------------------
//
// Constructs a pattern that matches null on the first attempt, and then causes
// the entire match to be aborted if a subsequent failure occurs.
Pattern Fence();

// Constructs a pattern that first matches P. if P fails, then the constructed
// pattern fails. If P succeeds, then the match proceeds, but if subsequent
// failure occurs, alternatives in P are not sought.  The idea of Fence is that
// each time the pattern is matched, just one attempt is made to match P,
// without trying alternatives.
Pattern Fence(const Pattern&amp; p);

// ----------------------------------------------------------------------------
///  Len
// ----------------------------------------------------------------------------
//
// Constructs a pattern that matches exactly the given number of characters. The
// pattern fails if fewer than this number of characters remain to be matched in
// the string.
Pattern Len(unsigned int count);
Pattern Len(UnsignedInterface *count);
Pattern Len(const unsigned int *count);

// ----------------------------------------------------------------------------
///  NotAny
// ----------------------------------------------------------------------------
//
// Constructs a pattern that matches a single character that is not one of the
// characters in the given argument. The pattern Fails if the current character
// is in str.

Pattern NotAny(Character c);
Pattern NotAny(const CharacterSet&amp; set);
Pattern NotAny(const std::string&amp; str);
Pattern NotAny(std::string* str);
Pattern NotAny(StringInterface *);

// ----------------------------------------------------------------------------
///  NSpan
// ----------------------------------------------------------------------------
//
// Constructs a pattern that matches the longest possible string consisting
// entirely of characters from the given argument. The string may be empty, so
// this pattern always succeeds.

// Null or Span (always succeeds)
// [NOT in SPITBOL]

Pattern NSpan(Character c);
Pattern NSpan(const CharacterSet&amp; set);
Pattern NSpan(const std::string&amp; str);
Pattern NSpan(std::string *str);
Pattern NSpan(StringInterface *);

// ----------------------------------------------------------------------------
///  Pos
// ----------------------------------------------------------------------------
//
// Constructs a pattern that matches the null string if exactly count characters
// have already been matched, and otherwise fails.

Pattern Pos(unsigned int count);
Pattern Pos(UnsignedInterface *);
Pattern Pos(const unsigned int *ptr);

// ----------------------------------------------------------------------------
///  Rem
// ----------------------------------------------------------------------------
//
// Constructs a pattern that always succeeds, matching the remaining unmatched
// characters in the pattern.

// SPITBOL: REM
// C++: Rem

Pattern Rem();

// ----------------------------------------------------------------------------
///  Rpos
// ----------------------------------------------------------------------------
//
// Constructs a pattern that matches the null string if exactly count characters
// remain to be matched in the string, and otherwise fails.

Pattern Rpos(unsigned int count);
Pattern Rpos(UnsignedInterface *);
Pattern Rpos(const unsigned int *ptr);

// ----------------------------------------------------------------------------
///  Rtab
// ----------------------------------------------------------------------------
//
// Constructs a pattern that matches from the current location until exactly
// count characters remain to be matched in the string. The pattern fails if
// fewer than count characters remain to be matched.

Pattern Rtab(unsigned int count);
Pattern Rtab(UnsignedInterface *);
Pattern Rtab(const unsigned int *ptr);

// ----------------------------------------------------------------------------
///  Setcur
// ----------------------------------------------------------------------------
//
// Constructs a pattern that matches the null string, and assigns the current
// cursor position in the string to var. This value is the number of
// characters matched so far. So it is zero at the start of the match.
//
// SPITBOL: unary "@"
// C++: Setcur

Pattern Setcur(unsigned int &amp;var);

// ----------------------------------------------------------------------------
///  Span
// ----------------------------------------------------------------------------
//
// Constructs a pattern that matches the longest possible string consisting
// entirely of characters from the given argument. The string cannot be empty ,
// so the pattern fails if the current character is not one of the characters in
// str.

Pattern Span(Character c);
Pattern Span(const CharacterSet&amp; set);
Pattern Span(const std::string&amp; str);
Pattern Span(const std::string *str);
Pattern Span(StringInterface *);

// ----------------------------------------------------------------------------
///  Succeed
// ----------------------------------------------------------------------------
//
// Constructs a pattern that succeeds matching null, both on the first attempt,
// and on any rematch attempt, i.e. it is equivalent to an infinite alternation
// of null strings.

Pattern Succeed();

// ----------------------------------------------------------------------------
///  Tab
// ----------------------------------------------------------------------------
//
// Constructs a pattern that from the current location until count characters
// have been matched. The pattern fails if more than count characters have
// already been matched.

Pattern Tab(unsigned int count);
Pattern Tab(UnsignedInterface *);
Pattern Tab(const unsigned int *ptr);

// ----------------------------------------------------------------------------
/// Pattern Matching Operations
// ----------------------------------------------------------------------------
//
// The Match function performs an actual pattern matching operation.  The
// versions with two parameters perform a match without modifying the subject
// string and return a bool result indicating if the match is successful or
// not.
//
// Note that pattern assignment functions in the pattern may generate side
// effects, so these functions are not necessarily pure.
//
// Pattern::anchor
//
//   This flag can be set to cause all subsequent pattern matches to operate in
//   anchored mode. In anchored mode, no attempt is made to move the anchor
//   point, so that if the match succeeds it must succeed starting at the first
//   character. Note that the effect of anchored mode may be achieved in
//   individual pattern matches by using Fence or Pos(0) at the start of the
//   pattern.
//
//   In an unanchored match, which is the default, successive attempts are made
//   to match the given pattern at each character of the subject string until a
//   match succeeds, or until all possibilities have failed.

// ----------------------------------------------------------------------------
///  Match
// ----------------------------------------------------------------------------
//
// Simple match functions. The subject is matched against the pattern.  Any
// immediate or deferred assignments or writes are executed, and the returned
// value indicates whether or not the match succeeded.

bool Match(const Character *subj, const Pattern&amp; p, int flags = 0);
bool Match(const std::string&amp; subj, const Pattern&amp; p, int flags = 0);

// ----------------------------------------------------------------------------
///  Match &amp; Replacement
// ----------------------------------------------------------------------------
//
// The subject is matched against the pattern.  Any immediate or deferred
// assignments or writes are executed, and the returned value indicates whether
// or not the match succeeded.  If the match succeeds, then the matched part of
// the subject string is replaced by the given Replace string.

bool Match
(
    std::string&amp; subj,
    const Pattern&amp; p,
    const std::string&amp; replacement,
    int flags = 0
);

bool Match
(
    std::string&amp; subj,
    const Pattern&amp; p,
    const Character *replacement,
    int flags = 0
);

// ----------------------------------------------------------------------------
/// Debugging Routines
// ----------------------------------------------------------------------------
//
// Debugging pattern matching operations can often be quite complex, since there
// is no obvious way to trace the progress of the match.  The declarations in
// this section provide some debugging assistance.

// ----------------------------------------------------------------------------
///  Pattern::debug flag
// ----------------------------------------------------------------------------
//
// The Pattern::debug flag can be provided to the Match functions to generate
// debugging information. The debugging output is a full trace of the actions of
// the pattern matcher, written to cout. The level of this information is
// intended to be comprehensible at the abstract level of this package
// declaration. However, note that the use of this switch often generates large
// amounts of output.

// ----------------------------------------------------------------------------
///  Debug assignment
// ----------------------------------------------------------------------------
//
// These are similar to the corresponding pattern assignment operations except
// that instead of setting the value of a variable, the matched sub-string is
// written to the appropriate file. This can be useful in following the progress
// of a match without generating the full amount of information obtained by
// setting Debug_Mode to True.
Pattern operator%(const Pattern&amp; p, std::ostream &amp;);
Pattern operator*(const Pattern&amp; p, std::ostream &amp;);

// ----------------------------------------------------------------------------
///  Dump pattern (as table) to std::ostream
// ----------------------------------------------------------------------------
//
// This procedure writes information about the pattern to the std::ostream
// provided.  The format of this information is keyed to the internal data
// structures used to implement patterns. The information provided by Dump is
// thus more precise than that yielded by Image, but is also a bit more obscure
// (i.e. it cannot be interpreted solely in terms of this spec, you have to know
// something about the data structures).
//
// void Pattern::dump(std::ostream &amp;) const;

// ----------------------------------------------------------------------------
///  Write pattern to std::ostream
// ----------------------------------------------------------------------------
//
// This output operator writes a string representation of the pattern that
// corresponds to the syntax needed to create the given pattern using the
// functions in this package. The form of this string is such that it could
// actually be compiled and evaluated to yield the required pattern except for
// references to variables and functions.
std::ostream&amp; operator&lt;&lt;(std::ostream &amp;, const Pattern&amp; p);

// -----------------------------------------------------------------------------
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2016-08-21 Sun 14:48</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
